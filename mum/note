W1D2

Algorithm arrayMax(A,n)

Input array A of n integers
Output maximum elemtn of A

currentMax <- A[0]
for i<- 1 to n-1 do
if A[i] > currentMax then
currentmax <- A[i]

return currentMax
--------------------------------------------------------------------------------
Remove duplicates algorithm: Translate into pseudo-code:
Given a list L, return a list M of the distinct elements of L by doing the following: 
    For each n less than size of L, if L[n] is not yet in M, then add L[n] to M.
    
    Algorithm removeDuplicate(L,M)
    Input a list L
    Output a list M containing the distinct elements of L
    int count = 0
    boolean flag = false
    for i<- 0 to L.size-1 do
      for j <- 0 to M.size -1 do
      if(L[i]=M[j]) flag=true;
    if(!flag)  
    M[count++] = L[i]
    
    return M
    
------------------------------------------------------------------
-------------------------Assignments------------------------------
1. Compute the number of primitive operations for each of the following algorithm
fragments. The “increment counter” step has not been mentioned explicitly – be sure
to take this into account in your computations. Hint: When faced with nested for
loops, compute the number of steps required by the inner loop first, and then figure
out the effect of the outer loop.
A. sum ← 0                    [1]
for i ← 0 to n-1 do           [2n+n+1+1] n+1 conditioncheck , 2n increment and 1 assignment
sum ← sum + 1                 [n(1+1)] addition and assignment
--------------------------    ------------
total                          5n+3


B. sum ← 0                    [1] assignment
for i ← 0 to n-1 do           [3n+2]
for j ← 0 to n-1 do           n*[3n+2]
sum ← sum + 1                 n*n*2
-------------------------     --------------
total                         3+5n+5n2

----------------------------------------------------------------------
2. Determine the asymptotic running time of the following procedure (an exact
computation of number of basic operations is not necessary):

int[] arrays(int n) {
int[] arr = new int[n];

for(int i = 0; i < n; ++i){
arr[i] = 1;
}

for(int i = 0; i < n; ++i) {
for(int j = i; j < n; ++j){
arr[i] += arr[j] + i + j;
}
}

return arr;
}
Answer : O(n2)

------------------------------------------------------------------------
3. Consider the following problem: As input you are given two sorted arrays of integers.
Your objective is to design an algorithm that would merge the two arrays together to
form a new sorted array that contains all the integers contained in the two arrays. For
example, on input
[1, 4, 5, 8, 17], [2, 4, 8, 11, 13, 21, 23, 25]
the algorithm would output the following array:
[1,2,4,4,5,8,8, 11, 13, 17, 21, 23, 25]
For this problem, do the following:

A. Design an algorithm Merge to solve this problem and write your algorithm
description using the pseudo-code syntax discussed in class.

Algorithm merge (A, B, N)
int count =0;
int i=0;
int itr = A.size()+B.size()
while(count< itr)
{
if(A[a]>=B[b]
c[count++]=A[a++]
else(A[a]<B[b])
c[count++]=B[b++]

if(a==A.size())
while(b<=B.size)
C[count++] = B[b++]

if(b==B.size())
while(a<=A.size)
C[count++] = A[a++]





}

B. Examining your pseudo-code, determine the asymptotic running time of this
merge algorithm

C. Implement your pseudo-code as a Java method merge having the following
signature:
int[] merge(int[] arr1, int[] arr2)
Be sure to test your method in a main method to be sure it really works!

    



